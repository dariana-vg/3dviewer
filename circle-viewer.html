<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            font-family: Arial;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="info">Loading...</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        let camera, scene, renderer, model;
        const info = document.getElementById('info');
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        init();
        animate();
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);
            
            // Lights - bright and even
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            
            const light1 = new THREE.DirectionalLight(0xffffff, 0.8);
            light1.position.set(5, 5, 5);
            scene.add(light1);
            
            const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
            light2.position.set(-5, 3, 5);
            scene.add(light2);
            
            const light3 = new THREE.DirectionalLight(0xffffff, 0.4);
            light3.position.set(0, -5, -5);
            scene.add(light3);
            
            // Load model
            const loader = new THREE.GLTFLoader();
            
            info.textContent = 'Loading model...';
            console.log('Starting to load model...');
            
            loader.load(
                './models/oven.glb',
                function(gltf) {
                    console.log('Model loaded successfully!');
                    model = gltf.scene;
                    
                    // Get size and center
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    
                    console.log('Model size:', size);
                    console.log('Model center:', center);
                    
                    // Center the model
                    model.position.sub(center);
                    
                    // Scale to fit nicely
                    const maxSize = Math.max(size.x, size.y, size.z);
                    const scale = 3 / maxSize;
                    model.scale.multiplyScalar(scale);
                    
                    console.log('Scale applied:', scale);
                    
                    scene.add(model);
                    
                    info.textContent = 'Drag to rotate freely';
                    console.log('Model added to scene');
                },
                function(xhr) {
                    const percent = Math.round((xhr.loaded / xhr.total) * 100);
                    info.textContent = `Loading: ${percent}%`;
                    console.log('Loading:', percent + '%');
                },
                function(error) {
                    info.textContent = 'ERROR loading model';
                    info.style.color = 'red';
                    console.error('Error loading model:', error);
                }
            );
            
            // Mouse controls - FREE ROTATION
            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
                console.log('Mouse down - start dragging');
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging && model) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    // FREE ROTATION - NO LIMITS
                    model.rotation.y += deltaX * 0.01;
                    model.rotation.x += deltaY * 0.01;
                    
                    console.log('Rotating - X:', model.rotation.x.toFixed(2), 'Y:', model.rotation.y.toFixed(2));
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
                console.log('Mouse up - stop dragging');
            });
            
            renderer.domElement.addEventListener('mouseleave', () => {
                isDragging = false;
            });
            
            // Touch controls - FREE ROTATION
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                    console.log('Touch start');
                    e.preventDefault();
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (isDragging && model && e.touches.length === 1) {
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;
                    
                    // FREE ROTATION - NO LIMITS
                    model.rotation.y += deltaX * 0.01;
                    model.rotation.x += deltaY * 0.01;
                    
                    console.log('Touch rotating - X:', model.rotation.x.toFixed(2), 'Y:', model.rotation.y.toFixed(2));
                    
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                    e.preventDefault();
                }
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchend', () => {
                isDragging = false;
                console.log('Touch end');
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // No auto-rotation - stays centered
            // User can drag to rotate freely in ANY direction
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
